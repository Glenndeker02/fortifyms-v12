import { NextRequest, NextResponse } from 'next/server'

/**
 * PowerPoint Export API
 *
 * NOTE: To enable full PowerPoint export functionality, install 'pptxgenjs' package:
 * npm install pptxgenjs
 *
 * Then uncomment the import and implementation below.
 */

// import PptxGenJS from 'pptxgenjs'

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const {
      reportType,
      reportData,
      title,
      subtitle,
      theme = 'modern',
      includeCharts = true,
      includeTables = true,
    } = body

    if (!reportType || !reportData) {
      return NextResponse.json(
        { error: 'reportType and reportData are required' },
        { status: 400 }
      )
    }

    // Build presentation structure
    const presentationStructure = buildPresentationStructure(
      reportType,
      reportData,
      title,
      subtitle,
      { theme, includeCharts, includeTables }
    )

    /**
     * Full implementation with pptxgenjs:
     *
     * const pptx = new PptxGenJS()
     *
     * // Set presentation properties
     * pptx.author = 'FortifyMIS System'
     * pptx.company = 'FortifyMIS'
     * pptx.subject = `${reportType} Report`
     * pptx.title = title || `${reportType} Report`
     *
     * // Apply theme
     * applyTheme(pptx, theme)
     *
     * // Add slides
     * presentationStructure.slides.forEach(slideConfig => {
     *   const slide = pptx.addSlide()
     *   buildSlide(slide, slideConfig, { includeCharts, includeTables })
     * })
     *
     * // Generate PowerPoint file
     * const pptxBuffer = await pptx.write({ outputType: 'arraybuffer' })
     *
     * return new NextResponse(pptxBuffer, {
     *   headers: {
     *     'Content-Type': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
     *     'Content-Disposition': `attachment; filename="${title || reportType}-${Date.now()}.pptx"`
     *   }
     * })
     */

    // For now, return structured data
    return NextResponse.json({
      success: true,
      format: 'powerpoint',
      presentationStructure,
      downloadUrl: `/api/analytics/export/powerpoint/download?id=${Date.now()}`,
      message:
        'PowerPoint structure generated. Install pptxgenjs package for actual file generation.',
      installCommand: 'npm install pptxgenjs',
    })
  } catch (error) {
    console.error('Error generating PowerPoint:', error)
    return NextResponse.json(
      { error: 'Failed to generate PowerPoint' },
      { status: 500 }
    )
  }
}

function buildPresentationStructure(
  reportType: string,
  data: any,
  title: string,
  subtitle: string,
  options: any
) {
  const slides: any[] = []

  // Title slide
  slides.push({
    type: 'title',
    layout: 'LAYOUT_TITLE',
    content: {
      title: title || `${reportType} Report`,
      subtitle: subtitle || `Generated by FortifyMIS on ${new Date().toLocaleDateString()}`,
      footer: 'FortifyMIS v12',
    },
  })

  // Agenda/Overview slide
  slides.push({
    type: 'agenda',
    layout: 'LAYOUT_TITLE_AND_CONTENT',
    content: {
      title: 'Overview',
      bullets: [
        'Executive Summary',
        'Key Performance Indicators',
        'Production & Quality Metrics',
        'Trends Analysis',
        'Recommendations',
      ],
    },
  })

  // Executive Summary slide
  if (data.summary || data.executiveSummary) {
    slides.push({
      type: 'summary',
      layout: 'LAYOUT_TITLE_AND_CONTENT',
      content: {
        title: 'Executive Summary',
        summary: data.summary || data.executiveSummary,
      },
    })
  }

  // KPI Dashboard slide
  if (data.kpis || data.keyMetrics) {
    slides.push({
      type: 'kpi-dashboard',
      layout: 'LAYOUT_BLANK',
      content: {
        title: 'Key Performance Indicators',
        kpis: formatKPIsForSlide(data.kpis || data.keyMetrics),
      },
    })
  }

  // Production metrics slide with chart
  if (data.production || data.batches) {
    slides.push({
      type: 'production',
      layout: 'LAYOUT_TITLE_AND_CONTENT',
      content: {
        title: 'Production Overview',
        chart: options.includeCharts
          ? {
              type: 'bar',
              data: formatProductionDataForChart(data.production || data.batches),
              chartColors: ['059669', '3b82f6', 'f59e0b'],
            }
          : null,
        table: options.includeTables
          ? formatProductionDataForTable(data.production || data.batches)
          : null,
      },
    })
  }

  // Quality metrics slide
  if (data.quality || data.qcTests) {
    slides.push({
      type: 'quality',
      layout: 'LAYOUT_TITLE_AND_CONTENT',
      content: {
        title: 'Quality Control Results',
        chart: options.includeCharts
          ? {
              type: 'pie',
              data: formatQualityDataForChart(data.quality || data.qcTests),
              showLegend: true,
            }
          : null,
        summary: calculateQualitySummary(data.quality || data.qcTests),
      },
    })
  }

  // Trends slide
  if (data.trends || data.dailyProduction || data.monthlyData) {
    slides.push({
      type: 'trends',
      layout: 'LAYOUT_TITLE_AND_CONTENT',
      content: {
        title: 'Trends Analysis',
        chart: options.includeCharts
          ? {
              type: 'line',
              data: formatTrendsDataForChart(
                data.trends || data.dailyProduction || data.monthlyData
              ),
              showDataLabels: false,
            }
          : null,
      },
    })
  }

  // Geographic distribution slide
  if (data.geographicData || data.geographicDistribution) {
    slides.push({
      type: 'geographic',
      layout: 'LAYOUT_TITLE_AND_CONTENT',
      content: {
        title: 'Geographic Distribution',
        chart: {
          type: 'bar',
          data: formatGeographicDataForChart(
            data.geographicData || data.geographicDistribution
          ),
        },
      },
    })
  }

  // Alerts and Issues slide
  if (data.alerts || data.issues) {
    slides.push({
      type: 'alerts',
      layout: 'LAYOUT_TITLE_AND_CONTENT',
      content: {
        title: 'Alerts & Critical Issues',
        table: formatAlertsForTable(data.alerts || data.issues),
      },
    })
  }

  // Recommendations slide
  if (data.recommendations) {
    slides.push({
      type: 'recommendations',
      layout: 'LAYOUT_TITLE_AND_CONTENT',
      content: {
        title: 'Recommendations',
        bullets: data.recommendations.map((r: any) => ({
          text: r.title || r.recommendation,
          subBullets: [r.description || r.details, `Impact: ${r.impact || 'TBD'}`],
        })),
      },
    })
  }

  // Closing slide
  slides.push({
    type: 'closing',
    layout: 'LAYOUT_TITLE',
    content: {
      title: 'Thank You',
      subtitle: 'Questions?',
      footer: 'support@fortifyms.com',
    },
  })

  return {
    title: title || `${reportType} Report`,
    author: 'FortifyMIS System',
    slides,
    theme: options.theme,
    metadata: {
      reportType,
      generatedAt: new Date().toISOString(),
      slideCount: slides.length,
    },
  }
}

function formatKPIsForSlide(kpis: any) {
  if (Array.isArray(kpis)) {
    return kpis
  }

  const formatted: any[] = []
  Object.entries(kpis).forEach(([category, metrics]: [string, any]) => {
    if (typeof metrics === 'object' && metrics !== null) {
      Object.entries(metrics).forEach(([key, value]) => {
        formatted.push({
          label: formatLabel(key),
          value: value,
          category: formatLabel(category),
        })
      })
    } else {
      formatted.push({
        label: formatLabel(category),
        value: metrics,
      })
    }
  })

  return formatted.slice(0, 8) // Limit to 8 KPIs per slide
}

function formatProductionDataForChart(production: any) {
  if (!Array.isArray(production)) return []

  return production.slice(0, 10).map((item: any) => ({
    name: item.date || item.batchId || item.name,
    value: item.production || item.output || item.outputWeight || 0,
  }))
}

function formatProductionDataForTable(production: any) {
  if (!Array.isArray(production)) return { headers: [], rows: [] }

  const headers = ['Date/Batch', 'Output (kg)', 'Yield %', 'QC Status']
  const rows = production.slice(0, 10).map((item: any) => [
    item.date || item.batchId,
    item.production || item.output || item.outputWeight || 0,
    item.avgYield || item.yieldPercentage || 'N/A',
    item.qcStatus || 'PENDING',
  ])

  return { headers, rows }
}

function formatQualityDataForChart(quality: any) {
  if (!Array.isArray(quality)) return []

  const statusCounts = quality.reduce((acc: any, item: any) => {
    const status = item.status || item.qcStatus || 'UNKNOWN'
    acc[status] = (acc[status] || 0) + 1
    return acc
  }, {})

  return Object.entries(statusCounts).map(([name, value]) => ({ name, value }))
}

function calculateQualitySummary(quality: any) {
  if (!Array.isArray(quality)) return {}

  const total = quality.length
  const passed = quality.filter(
    (q) => q.status === 'PASS' || q.qcStatus === 'PASS'
  ).length
  const failed = quality.filter(
    (q) => q.status === 'FAIL' || q.qcStatus === 'FAIL'
  ).length

  return {
    total,
    passed,
    failed,
    passRate: total > 0 ? Math.round((passed / total) * 100 * 100) / 100 : 0,
  }
}

function formatTrendsDataForChart(trends: any) {
  if (!Array.isArray(trends)) return []

  return trends.map((item: any) => ({
    date: item.date || item.month || item.period,
    production: item.production || item.totalOutput || 0,
    qcPassRate: item.qcPassRate || 0,
  }))
}

function formatGeographicDataForChart(geographic: any) {
  if (!Array.isArray(geographic)) return []

  return geographic.slice(0, 10).map((item: any) => ({
    name: item.country || item.region || item.name,
    value: item.mills || item.production || item.value || 0,
  }))
}

function formatAlertsForTable(alerts: any) {
  if (!Array.isArray(alerts)) return { headers: [], rows: [] }

  const headers = ['Date', 'Severity', 'Title', 'Status']
  const rows = alerts.slice(0, 10).map((alert: any) => [
    new Date(alert.createdAt || Date.now()).toLocaleDateString(),
    alert.severity || 'MEDIUM',
    alert.title || alert.message || 'Alert',
    alert.status || 'PENDING',
  ])

  return { headers, rows }
}

function formatLabel(str: string): string {
  return str
    .replace(/([A-Z])/g, ' $1')
    .replace(/^./, (s) => s.toUpperCase())
    .trim()
}

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const id = searchParams.get('id')

    if (!id) {
      return NextResponse.json({ error: 'PowerPoint ID required' }, { status: 400 })
    }

    return NextResponse.json({
      message: 'PowerPoint download endpoint - implement file retrieval from storage',
      id,
    })
  } catch (error) {
    console.error('Error downloading PowerPoint:', error)
    return NextResponse.json(
      { error: 'Failed to download PowerPoint' },
      { status: 500 }
    )
  }
}
