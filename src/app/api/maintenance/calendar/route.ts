import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { getMaintenanceStatus } from '@/lib/maintenance-utils'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const view = searchParams.get('view') || 'month' // month, week, list
    const startDate = searchParams.get('startDate')
    const endDate = searchParams.get('endDate')
    const equipmentType = searchParams.get('equipmentType')
    const location = searchParams.get('location')
    const assignedTo = searchParams.get('assignedTo')
    const millId = searchParams.get('millId')

    // Build date range
    let dateRange: any = {}
    if (startDate && endDate) {
      dateRange = {
        scheduledDate: {
          gte: new Date(startDate),
          lte: new Date(endDate),
        },
      }
    }

    // Build filters
    const where: any = { ...dateRange }
    if (assignedTo) where.assignedTo = assignedTo
    if (millId) where.millId = millId

    // Equipment filters
    const equipmentWhere: any = {}
    if (equipmentType) equipmentWhere.type = equipmentType
    if (location) equipmentWhere.location = location

    // Fetch tasks
    const tasks = await prisma.maintenanceTask.findMany({
      where: {
        ...where,
        equipment: Object.keys(equipmentWhere).length > 0 ? equipmentWhere : undefined,
      },
      include: {
        equipment: {
          select: {
            name: true,
            type: true,
            location: true,
          },
        },
        assignee: {
          select: {
            name: true,
            email: true,
          },
        },
        schedule: {
          select: {
            type: true,
            frequency: true,
            nextDueDate: true,
          },
        },
      },
      orderBy: { scheduledDate: 'asc' },
    })

    // Fetch upcoming schedules (for auto-generated tasks)
    const upcomingSchedules = await prisma.maintenanceSchedule.findMany({
      where: {
        isActive: true,
        nextDueDate: dateRange.scheduledDate || undefined,
        millId,
        equipment: Object.keys(equipmentWhere).length > 0 ? equipmentWhere : undefined,
      },
      include: {
        equipment: {
          select: {
            name: true,
            type: true,
            location: true,
          },
        },
      },
    })

    // Transform data for calendar view
    const calendarEvents = tasks.map((task) => {
      const status = getMaintenanceStatus(task.scheduledDate)

      return {
        id: task.id,
        title: `${task.type} - ${task.equipment.name}`,
        date: task.scheduledDate,
        status: task.status,
        priority: task.priority,
        urgency: status.status,
        severity: status.severity,
        daysRemaining: status.daysRemaining,
        equipment: task.equipment,
        assignee: task.assignee,
        description: task.description,
        type: task.type,
        color: getEventColor(status.status, task.status),
      }
    })

    // Add schedule events that don't have tasks yet
    const scheduleEvents = upcomingSchedules
      .filter(
        (schedule) =>
          !tasks.some((task) => task.scheduleId === schedule.id && task.status !== 'COMPLETED')
      )
      .map((schedule) => {
        const status = getMaintenanceStatus(schedule.nextDueDate)

        return {
          id: `schedule-${schedule.id}`,
          title: `${schedule.type} - ${schedule.equipment.name}`,
          date: schedule.nextDueDate,
          status: 'SCHEDULED',
          priority: 'MEDIUM',
          urgency: status.status,
          severity: status.severity,
          daysRemaining: status.daysRemaining,
          equipment: schedule.equipment,
          description: schedule.description,
          type: schedule.type,
          color: getEventColor(status.status, 'SCHEDULED'),
          isAutoGenerated: true,
          scheduleId: schedule.id,
        }
      })

    const allEvents = [...calendarEvents, ...scheduleEvents]

    // Group by date for calendar view
    if (view === 'month' || view === 'week') {
      const groupedByDate = allEvents.reduce((acc: any, event) => {
        const dateKey = new Date(event.date).toISOString().split('T')[0]
        if (!acc[dateKey]) {
          acc[dateKey] = []
        }
        acc[dateKey].push(event)
        return acc
      }, {})

      return NextResponse.json({
        view,
        events: groupedByDate,
        summary: {
          total: allEvents.length,
          overdue: allEvents.filter((e) => e.urgency === 'OVERDUE').length,
          dueSoon: allEvents.filter((e) => e.urgency === 'DUE_SOON').length,
          upcoming: allEvents.filter((e) => e.urgency === 'DUE_UPCOMING').length,
        },
      })
    }

    // List view
    return NextResponse.json({
      view: 'list',
      events: allEvents,
      summary: {
        total: allEvents.length,
        overdue: allEvents.filter((e) => e.urgency === 'OVERDUE').length,
        dueSoon: allEvents.filter((e) => e.urgency === 'DUE_SOON').length,
        upcoming: allEvents.filter((e) => e.urgency === 'DUE_UPCOMING').length,
      },
    })
  } catch (error) {
    console.error('Error fetching maintenance calendar:', error)
    return NextResponse.json(
      { error: 'Failed to fetch calendar data' },
      { status: 500 }
    )
  }
}

function getEventColor(urgency: string, taskStatus: string): string {
  if (taskStatus === 'COMPLETED') return 'green'
  if (taskStatus === 'CANCELLED') return 'gray'

  switch (urgency) {
    case 'OVERDUE':
      return 'red'
    case 'DUE_SOON':
      return 'yellow'
    case 'DUE_UPCOMING':
      return 'blue'
    default:
      return 'green'
  }
}
